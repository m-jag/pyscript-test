declare const _default: any;
export default _default;
declare class Qn extends Vn {
    constructor(e: any);
    readUint8Array(e: any, t: any): Promise<Uint8Array>;
}
declare class Yn extends Hn {
    constructor(e: any);
    blob: Promise<Blob>;
    getData(): Promise<Blob>;
}
declare class Kn extends Vn {
    constructor(e: any);
    readUint8Array(e: any, t: any): Uint8Array;
}
declare class Xn extends Zn {
    constructor(e: any);
    writeUint8Array(e: any): void;
    pending: any;
    getData(): string;
}
declare const Kr: "File format is not recognized";
declare const Yr: "Central directory header not found";
declare const _i: "File already exists";
declare const ei: "File contains encrypted entry";
declare const Qr: "End of Zip64 central directory locator not found";
declare const Xr: "End of central directory not found";
declare const $r: "Zip64 extra field not found";
declare const On: "HTTP Range not supported";
declare const ki: "Zip file comment exceeds 64KB";
declare const ji: "The strength must equal 1, 2, or 3";
declare const Si: "File entry comment exceeds 64KB";
declare const zi: "File entry name exceeds 64KB";
declare const Ci: "Extra field data exceeds 64KB";
declare const Di: "Extra field type exceeds 65535";
declare const ut: "Invalid password";
declare const pt: "Invalid signature";
declare const Ai: "Version exceeds 65535";
declare const Wn: "Writer iterator completed too soon";
declare const Jr: "Local file header not found";
declare const ri: "Split zip file";
declare const ni: "Compression method not supported";
declare const ti: "Encryption method not supported";
declare const Fi: "Zip64 is not supported (make sure 'keepOrder' is set to 'true')";
declare class mr extends pr {
}
declare class pr extends Vn {
    constructor(e: any, t?: {});
    set size(e: any);
    get size(): any;
    init(): Promise<void>;
    readUint8Array(e: any, t: any): any;
}
declare class Vn extends Hn {
    get readable(): ReadableStream<any>;
}
declare class xr extends Vn {
    constructor(e: any);
    readers: any;
    init(): Promise<void>;
    lastDiskNumber: any;
    lastDiskOffset: number;
    readUint8Array(e: any, t: any, n?: number): Promise<any>;
}
declare class gr extends Hn {
    constructor(e: any, t?: number);
}
declare const kr: typeof xr;
declare const Sr: typeof gr;
declare class Jn extends Qn {
}
declare class $n extends Yn {
    getData(): Promise<any>;
}
declare class hr extends Vn {
    constructor(e: any);
    readUint8Array(e: any, t: any): any;
}
declare class wr extends Zn {
    init(e?: number): void;
    writeUint8Array(e: any): void;
    getData(): any;
}
declare class Zn extends Hn {
    writeUint8Array(): void;
}
declare class ci {
    constructor(e: any, t?: {});
    getEntriesGenerator(e?: {}): AsyncGenerator<Zr, boolean, unknown>;
    prependedData: any;
    comment: any;
    appendedData: any;
    getEntries(e?: {}): Promise<Zr[]>;
    close(): Promise<void>;
}
declare class li {
    constructor(e?: {});
    readable: ReadableStream<any>;
    writable: WritableStream<any>;
}
declare class qi {
    constructor(e: any, t?: {});
    add(e: string, t: any, n?: {}): Promise<Zr>;
    close(e?: Uint8Array, t?: {}): Promise<any>;
}
declare class Ri {
    constructor(e?: {});
    readable: ReadableStream<any>;
    zipWriter: qi;
    transform(e: any): {
        readable: ReadableStream<any>;
        writable: WritableStream<any>;
    };
    writable(e: any): WritableStream<any>;
    close(e?: any, t?: {}): Promise<any>;
}
declare function Xe(e: any): void;
declare namespace Xi {
    export { FS };
    export { Ki as ZipDirectoryEntry };
    export { Zi as ZipFileEntry };
}
declare function $e(e: any): any;
declare function Tn(e: any, t: {}, n: any): {
    Deflate: {
        new (r: any): {
            codec: any;
            append(e: any): any;
            flush(): any;
        };
    };
    Inflate: {
        new (r: any): {
            codec: any;
            append(e: any): any;
            flush(): any;
        };
    };
};
declare function Un(): Promise<void>;
declare class Hn {
    size: number;
    init(): void;
    initialized: boolean;
}
declare class Zr {
    constructor(e: any);
}
declare class FS {
    get children(): any;
    remove(e: any): void;
    move(e: any, t: any): void;
    find(e: any): any;
    getById(e: any): any;
    getChildByName(e: any): any;
    addDirectory(e: any, t: any): any;
    addText(e: any, t: any, n: any): any;
    addBlob(e: any, t: any, n: any): any;
    addData64URI(e: any, t: any, n: any): any;
    addUint8Array(e: any, t: any, n: any): any;
    addHttpContent(e: any, t: any, n: any): any;
    addReadable(e: any, t: any, n: any): any;
    addFileSystemEntry(e: any, t: any): any;
    addFileSystemHandle(e: any, t: any): any;
    addFile(e: any, t: any): any;
    addData(e: any, t: any): any;
    importBlob(e: any, t: any): any;
    importData64URI(e: any, t: any): any;
    importUint8Array(e: any, t: any): any;
    importHttpContent(e: any, t: any): any;
    importReadable(e: any, t: any): any;
    importZip(e: any, t: any): any;
    exportBlob(e: any): any;
    exportData64URI(e: any): any;
    exportUint8Array(e: any): any;
    exportWritable(e: any, t: any): any;
    isPasswordProtected(): any;
    checkPassword(e: any, t: any): Promise<any>;
}
declare class Ki extends Vi {
    directory: boolean;
    clone(e: any): Ki;
    addDirectory(e: any, t: any): Zi | Ki;
    addText(e: any, t: any, n?: {}): Zi | Ki;
    addBlob(e: any, t: any, n?: {}): Zi | Ki;
    addData64URI(e: any, t: any, n?: {}): Zi | Ki;
    addUint8Array(e: any, t: any, n?: {}): Zi | Ki;
    addHttpContent(e: any, t: any, n?: {}): Zi | Ki;
    addReadable(e: any, t: any, n?: {}): Zi | Ki;
    addFileSystemEntry(e: any, t?: {}): Promise<any[]>;
    addFileSystemHandle(e: any, t?: {}): Promise<any[]>;
    addFile(e: any, t?: {}): Zi | Ki;
    addData(e: any, t: any): Zi | Ki;
    importBlob(e: any, t: any): Promise<(Zi | Ki)[]>;
    importData64URI(e: any, t: any): Promise<(Zi | Ki)[]>;
    importUint8Array(e: any, t: any): Promise<(Zi | Ki)[]>;
    importHttpContent(e: any, t: any): Promise<(Zi | Ki)[]>;
    importReadable(e: any, t: any): Promise<(Zi | Ki)[]>;
    exportBlob(e?: {}): Promise<any>;
    exportData64URI(e?: {}): Promise<any>;
    exportUint8Array(e?: {}): Promise<any>;
    exportWritable(e?: WritableStream<any>, t?: {}): Promise<WritableStream<any>>;
    importZip(e: any, t?: {}): Promise<(Zi | Ki)[]>;
    exportZip(e: any, t: any): Promise<any>;
    getChildByName(e: any): any;
    isPasswordProtected(): boolean;
    checkPassword(e: any, t?: {}): Promise<boolean>;
}
declare class Zi extends Vi {
    Reader: any;
    Writer: any;
    getData(e: any, t?: {}): Promise<any>;
    clone(): Zi;
    isPasswordProtected(): any;
    checkPassword(e: any, t?: {}): Promise<boolean>;
    getText(e: any, t: any): Promise<any>;
    getBlob(e: any, t: any): Promise<any>;
    getData64URI(e: any, t: any): Promise<any>;
    getUint8Array(e: any): Promise<any>;
    getWritable(e: WritableStream<any>, t: any): Promise<any>;
    replaceBlob(e: any): void;
    replaceText(e: any): void;
    replaceData64URI(e: any): void;
    replaceUint8Array(e: any): void;
    replaceReadable(e: any): void;
}
declare class Vi {
    constructor(e: any, t: any, n: any, r: any);
    moveTo(e: any): void;
    getFullname(): any;
    getRelativeName(e?: any): any;
    isDescendantOf(e: any): boolean;
    rename(e: any): void;
    name: any;
}
export { Qn as BlobReader, Yn as BlobWriter, Kn as Data64URIReader, Xn as Data64URIWriter, Kr as ERR_BAD_FORMAT, Yr as ERR_CENTRAL_DIRECTORY_NOT_FOUND, _i as ERR_DUPLICATED_NAME, ei as ERR_ENCRYPTED, Qr as ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND, Xr as ERR_EOCDR_NOT_FOUND, $r as ERR_EXTRAFIELD_ZIP64_NOT_FOUND, On as ERR_HTTP_RANGE, ki as ERR_INVALID_COMMENT, ji as ERR_INVALID_ENCRYPTION_STRENGTH, Si as ERR_INVALID_ENTRY_COMMENT, zi as ERR_INVALID_ENTRY_NAME, Ci as ERR_INVALID_EXTRAFIELD_DATA, Di as ERR_INVALID_EXTRAFIELD_TYPE, ut as ERR_INVALID_PASSWORD, pt as ERR_INVALID_SIGNATURE, Ai as ERR_INVALID_VERSION, Wn as ERR_ITERATOR_COMPLETED_TOO_SOON, Jr as ERR_LOCAL_FILE_HEADER_NOT_FOUND, ri as ERR_SPLIT_ZIP_FILE, ni as ERR_UNSUPPORTED_COMPRESSION, ti as ERR_UNSUPPORTED_ENCRYPTION, Fi as ERR_UNSUPPORTED_FORMAT, mr as HttpRangeReader, pr as HttpReader, Vn as Reader, xr as SplitDataReader, gr as SplitDataWriter, kr as SplitZipReader, Sr as SplitZipWriter, Jn as TextReader, $n as TextWriter, hr as Uint8ArrayReader, wr as Uint8ArrayWriter, Zn as Writer, ci as ZipReader, li as ZipReaderStream, qi as ZipWriter, Ri as ZipWriterStream, Xe as configure, Xi as fs, $e as getMimeType, Tn as initShimAsyncCodec, Un as terminateWorkers };
